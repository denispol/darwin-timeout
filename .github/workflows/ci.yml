# CI workflow for darwin-timeout.
#
# Fast feedback on every push/PR: lint first (fast fail), then test.
# See CONTRIBUTING.md "CI Auto-Verification Rules" for the full test matrix.

name: CI

on:
  push:
    branches: [main, dev]
    tags-ignore:
      - 'v*'
  pull_request:
    # run on all PRs, not just main

env:
  CARGO_TERM_COLOR: always

jobs:
  # Lint first - fast fail before expensive test matrix
  lint:
    name: Lint
    runs-on: macos-15
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Rust
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: "1.91"
          components: clippy, rustfmt

      - name: Cache cargo
        uses: Swatinem/rust-cache@v2

      - name: Check formatting
        run: cargo fmt --check

      - name: Run clippy
        run: cargo clippy --all-targets -- -D warnings

      - name: Security audit
        run: |
          cargo install cargo-audit --quiet
          cargo audit

  # Test on macOS after lint passes.
  # x86_64 binary is cross-compiled and verified in release workflow.
  # Intel-specific CI runners (macos-15-large) require paid plan.
  test:
    name: Test
    needs: lint
    runs-on: macos-15
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Rust
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: "1.91"

      - name: Cache cargo
        uses: Swatinem/rust-cache@v2

      # tests run in debug mode - release builds use no_std with custom panic
      # handler that conflicts with std's panic handler in test harness
      - name: Run unit tests
        run: cargo test --lib

      - name: Run integration tests
        run: cargo test --test integration

      - name: Run proptest (30 properties)
        run: cargo test --test proptest

      - name: Verify binary
        run: |
          cargo build --release
          ./target/release/timeout --version
          ./target/release/timeout 0.1s sleep 60 || true

      - name: Verify binary size
        run: |
          SIZE=$(stat -f%z target/release/timeout)
          echo "Binary size: $SIZE bytes ($(($SIZE / 1024))KB)"
          if [ $SIZE -gt 150000 ]; then
            echo "ERROR: Binary too large (>150KB)"
            exit 1
          fi

      - name: Verify symbol count
        run: |
          SYMBOLS=$(nm -U target/release/timeout 2>/dev/null | wc -l)
          echo "Exported symbols: $SYMBOLS"
          if [ $SYMBOLS -gt 100 ]; then
            echo "ERROR: Too many symbols (>100), check strip settings"
            exit 1
          fi

  # Run Miri on unit tests to detect undefined behavior in unsafe code.
  # Focuses on pure-Rust modules: sync.rs (AtomicOnce), signal.rs, duration.rs,
  # args.rs parsing, and runner.rs exit code logic.
  #
  # Tests using libc FFI (process spawning, I/O, signal delivery) are gated
  # with #[cfg(not(miri))] since Miri cannot interpret macOS syscalls like
  # posix_spawn*, kill, or write. These are covered by integration tests.
  miri:
    name: Miri (UB detection)
    needs: lint
    runs-on: macos-15
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Rust nightly with Miri
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: nightly
          components: miri

      - name: Cache cargo
        uses: Swatinem/rust-cache@v2

      - name: Run Miri on unit tests
        run: cargo +nightly miri test --lib
        env:
          # Disable isolation to allow some FFI stubs, though most libc calls
          # will still be unsupported. This catches UB in pure Rust unsafe code.
          MIRIFLAGS: -Zmiri-disable-isolation
